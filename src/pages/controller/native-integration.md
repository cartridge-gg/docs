---
title: Native Integration
description: Learn how to integrate Controller into native applications.
---

Controller was initially developed as a web wallet, designed to be integrated into browser-based applications.
As the ecosystem has grown more ambitious, there has been growing demand for integrating Controller into native and mobile applications directly.

This guide will explain how to integrate Controller into native and mobile applications.

## Controller.c

The Controller source code is written in Rust -- chosen for its developer ergonomics, type and memory safety, portability, and performance.
Supporting native integrations of Controller meant generating FFI (Foreign Function Interfaces) definitions for C, a foundational language which can be easily imported into many programming environments -- including C++, Python, Kotlin, Objective-C, and more.

With Controller.c, application developers can integrate Controller into their native applications.

:::info
Controller's FFI definitions are generated by [`rust-diplomat`](https://github.com/rust-diplomat/diplomat).
:::

## Session Creation

Creating sessions with Controller.c differs from creating sessions with the regular Controller.
With the web-based Controller, session creation occurs inside of a secure keychain and the application cannot access signing keys directly.
With native applications, the signing key is created by the application itself and linked to the user's account through a one-time login flow.

The following is a high-level summary of the session-creation flow:

::::steps

#### Native application generates a new keypair

The native application generates a new keypair using a local utility like `ssh-keygen`.
The application should securely store the private key and use it to sign transactions for the user.

#### Native application initiates the Controller login flow

In order to link the keypair to the user's Controller account, the application will initiate the Controller connect flow, passing in the keypair's public key and a Merkle root of the policy object for session creation.
This flow will open a browser window inside the application interface, with the key and policy root as URL arguments, and prompt the user to log in with Controller.

#### Keychain authorizes and records session onchain

Inside of the local browser, the keychain will sign the public key and the policy root using the user's Controller credentials.
This signed payload will then be recorded onchain and used to validate future transactions.
As a final step, the native application will receive a GraphQL push with the user's Controller address, which the native application should use when preparing transactions.

#### Native application sends transactions

Once the signed session has been recorded onchain, the native application can then sign transactions using the session signer.
These signed transactions will be validated against the recorded session payload and executed.

::::

## Integrating Controller

Here is an example of how to integrate Controller.c:

```c
  #include "bindings/c/CONTROLLERS.h"
  #include "bindings/c/Controller.h"
  #include "bindings/c/DiplomatCall.h"
  #include "bindings/c/DiplomatOwner.h"

  // Setup
  char buffer[256];
  DiplomatWrite writeable = diplomat_simple_write(buffer, sizeof(buffer));

  // Get class hash
  CONTROLLERS_get_class_hash(Version_LATEST, &writeable);

  // Create owner from private key
  DiplomatStringView private_key = {"0x1234...", 66}; // Note: never commit private keys in source code
  DiplomatOwner *owner = DiplomatOwner_new_from_starknet_signer(private_key).ok;

  // Create controller
  Controller *controller = Controller_new_headless(
      (DiplomatStringView){"my_app", 6},     // app_id
      (DiplomatStringView){"user123", 7},    // username
      (DiplomatStringView){buffer, strlen(buffer)}, // class_hash
      (DiplomatStringView){"https://starknet-mainnet.public.blastapi.io", 43}, // rpc_url
      owner,
      (DiplomatStringView){"0x534e5f4d41494e", 16} // chain_id
  ).ok;

  // Create transaction call
  DiplomatCall *call = DiplomatCall_new(
      (DiplomatStringView){"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7", 66}, // contract
      (DiplomatStringView){"0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e", 64}    // selector
  );

  // Add call data
  DiplomatCall_push_calldata_str(call, (DiplomatStringView){"0x123...", 5}); // recipient
  DiplomatCall_push_calldata_str(call, (DiplomatStringView){"0x64", 4});     // amount

  // Execute
  DiplomatCallList *calls = DiplomatCallList_new();
  DiplomatCallList_add_call(calls, call);

  writeable = diplomat_simple_write(buffer, sizeof(buffer));
  Controller_execute(controller, calls, &writeable);
  printf("Transaction hash: %.*s\n", (int)writeable.len, buffer);
```

:::info
A complete integration example [is available here](https://github.com/cartridge-gg/controller.c/blob/main/examples/test_controller.c).
:::
